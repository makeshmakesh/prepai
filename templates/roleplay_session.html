{% extends 'base.html' %}
{% load static %}

{% block title %}{{ bot.name }} - AI Roleplay Session - PrepAI{% endblock %}

{% block extra_css %}
<style>
    /* Minimal Performance-Optimized Design */
    html, body {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        color: #ffffff;
        min-height: 100vh;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .content {
        background: transparent;
        max-width: 900px;
        padding: 1rem;
    }

    /* Main Container */
    .session-container {
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
        padding: 2rem;
        margin: 1rem auto;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    /* Character Info - Simplified */
    .character-info {
        display: flex;
        align-items: center;
        gap: 1.5rem;
        margin-bottom: 2rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .character-avatar {
        width: 80px;
        height: 80px;
        border-radius: 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        color: white;
        flex-shrink: 0;
        border: 2px solid rgba(255, 255, 255, 0.15);
    }

    .character-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 10px;
    }

    .character-details h1 {
        font-size: 1.8rem;
        font-weight: 600;
        margin: 0 0 0.5rem 0;
        color: #ffffff;
    }

    .character-details p {
        color: rgba(255, 255, 255, 0.7);
        margin: 0 0 0.5rem 0;
        font-size: 0.95rem;
        line-height: 1.4;
    }

    .scenario-tag {
        display: inline-block;
        background: rgba(102, 126, 234, 0.2);
        border: 1px solid rgba(102, 126, 234, 0.3);
        color: #a5b4fc;
        padding: 0.25rem 0.75rem;
        border-radius: 6px;
        font-size: 0.85rem;
        font-weight: 500;
    }

    /* Status Bar - Clean */
    .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 2rem;
    }

    .connection-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        font-weight: 500;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ef4444;
    }

    .status-dot.connecting { background: #f59e0b; }
    .status-dot.connected { background: #22c55e; }

    .session-stats {
        display: flex;
        gap: 2rem;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.7);
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        display: block;
        font-weight: 600;
        color: #ffffff;
        font-size: 1rem;
    }

    .stat-label {
        font-size: 0.8rem;
        opacity: 0.8;
    }

    /* Controls - Professional */
    .voice-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 2rem;
    }

    .control-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        font-weight: 500;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        min-height: 48px;
    }

    .control-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.15);
        border-color: rgba(255, 255, 255, 0.3);
    }

    .control-btn:disabled {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.4);
        cursor: not-allowed;
    }

    .control-btn.primary {
        background: rgba(102, 126, 234, 0.3);
        border-color: rgba(102, 126, 234, 0.5);
        color: #ffffff;
    }

    .control-btn.primary:hover:not(:disabled) {
        background: rgba(102, 126, 234, 0.4);
        border-color: rgba(102, 126, 234, 0.6);
    }

    .control-btn.recording {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.5);
        animation: recording-pulse 2s ease-in-out infinite;
    }

    .control-btn.danger {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
    }

    .control-btn.danger:hover:not(:disabled) {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.4);
    }

    @keyframes recording-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    /* Audio Level Indicator - Minimal */
    .audio-level {
        margin-bottom: 2rem;
    }

    .audio-level-label {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.8);
        margin-bottom: 0.5rem;
        font-weight: 500;
    }

    .audio-level-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
    }

    .audio-level-fill {
        height: 100%;
        background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);
        width: 0%;
        transition: width 0.1s ease;
        border-radius: 3px;
    }

    /* Conversation Area - Clean */
    .conversation-area {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        padding: 1rem;
        margin-bottom: 1rem;
    }

    .conversation-message {
        margin-bottom: 1rem;
        padding: 0.75rem;
        border-radius: 6px;
        font-size: 0.9rem;
        line-height: 1.4;
        word-wrap: break-word;
    }

    .message-system {
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.6);
        text-align: center;
        font-style: italic;
        font-size: 0.85rem;
    }

    .message-user {
        background: rgba(102, 126, 234, 0.15);
        border-left: 3px solid #667eea;
        color: #ffffff;
    }

    .message-assistant {
        background: rgba(34, 197, 94, 0.15);
        border-left: 3px solid #22c55e;
        color: #ffffff;
    }

    .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.25rem;
    }

    .message-speaker {
        font-weight: 600;
        font-size: 0.85rem;
    }

    .message-time {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.5);
        font-family: 'Monaco', monospace;
    }

    .message-content {
        color: rgba(255, 255, 255, 0.9);
    }

    /* Loading Overlay - Minimal */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(26, 26, 46, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }

    .loading-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid rgba(255, 255, 255, 0.2);
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Custom scrollbar */
    .conversation-area::-webkit-scrollbar {
        width: 6px;
    }

    .conversation-area::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
    }

    .conversation-area::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    .conversation-area::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    /* Character Status Indicator */
    .character-status {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
        padding: 0.4rem 0.8rem;
        border-radius: 6px;
        font-size: 0.8rem;
        font-weight: 500;
        border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .character-status.speaking {
        background: rgba(102, 126, 234, 0.2);
        color: #667eea;
        border-color: rgba(102, 126, 234, 0.3);
    }

    .character-status.processing {
        background: rgba(245, 158, 11, 0.2);
        color: #f59e0b;
        border-color: rgba(245, 158, 11, 0.3);
    }

    /* Modal Styling */
    .modal-content {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        color: #1f2937;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
        .session-container {
            padding: 1.5rem;
            margin: 0.5rem;
        }

        .character-info {
            flex-direction: column;
            text-align: center;
            gap: 1rem;
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
        }

        .character-details h1 {
            font-size: 1.5rem;
        }

        .status-bar {
            flex-direction: column;
            gap: 1rem;
        }

        .session-stats {
            gap: 1rem;
        }

        .voice-controls {
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        .conversation-area {
            height: 300px;
            padding: 0.75rem;
        }

        .character-status {
            position: static;
            display: inline-block;
            margin-top: 0.5rem;
        }
    }

    @media (max-width: 480px) {
        .session-container {
            padding: 1rem;
        }

        .session-stats {
            flex-direction: column;
            gap: 0.5rem;
        }
    }

    /* Performance optimizations - reduce animations on lower-end devices */
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="session-container fade-in-on-scroll">
    <div class="character-status" id="characterStatus">
        Ready
    </div>

    <!-- Character Info -->
    <div class="character-info">
        <div class="character-avatar">
            {% if bot.avatar_url %}
                <img src="{{ bot.avatar_url }}" alt="{{ bot.name }} Avatar">
            {% else %}
                🎭
            {% endif %}
        </div>
        <div class="character-details">
            <h1>{{ bot.name }}</h1>
            <p>{{ bot.description }}</p>
            <div class="scenario-tag">{{ bot.scenario_description }}</div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="connection-status" id="connectionStatus">
            <div class="status-dot connecting" id="statusDot"></div>
            <span id="statusText">Connecting to {{ bot.name }}...</span>
        </div>
        <div class="session-stats">
            <div class="stat-item">
                <span id="sessionTime" class="stat-value">00:00</span>
                <span class="stat-label">Duration</span>
            </div>
            <div class="stat-item">
                <span id="messageCount" class="stat-value">0</span>
                <span class="stat-label">Messages</span>
            </div>
        </div>
    </div>

    <!-- Voice Controls -->
    <div class="voice-controls">
        <button id="startBtn" class="control-btn primary" disabled>
            Start Recording
        </button>
        <button id="stopBtn" class="control-btn" disabled>
            Stop Recording
        </button>
        <button id="interruptBtn" class="control-btn" disabled>
            Interrupt
        </button>
        <button id="endBtn" class="control-btn danger" disabled>
            End Session
        </button>
    </div>

    <!-- Audio Level -->
    <div class="audio-level">
        <div class="audio-level-label">Microphone Level</div>
        <div class="audio-level-bar">
            <div id="audioLevelFill" class="audio-level-fill"></div>
        </div>
    </div>

    <!-- Conversation -->
    <div class="conversation-area" id="conversationArea">
        <div class="conversation-message message-system">
            <div class="message-content">
                Initializing roleplay session with {{ bot.name }}... Please wait.
            </div>
        </div>
    </div>
</div>

<!-- End Session Modal -->
<div class="modal fade" id="endSessionModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">End Roleplay Session</h5>
                <button type="button" class="close" data-dismiss="modal">
                    <span>&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to end your roleplay session with {{ bot.name }}?</p>
                <p class="text-muted">Your conversation will be saved automatically.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Continue</button>
                <button type="button" class="btn btn-danger" onclick="endRoleplay()">End Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
</div>
{% endblock %}

{% block extra_js %}
<script>
class RoleplaySession {
    constructor() {
        this.socket = null;
        this.mediaRecorder = null;
        this.audioStream = null;
        this.audioContext = null;
        this.playbackContext = null;
        this.analyser = null;
        this.isRecording = false;
        this.isConnected = false;
        this.SAMPLE_RATE = 24000;
        this.sessionStartTime = new Date();
        this.messageCount = 0;
        this.roleplayEnded = false;

        // Audio streaming queue
        this.audioQueue = [];
        this.isPlaying = false;
        this.isBotSpeaking = false;

        this.initializeElements();
        this.connect();
        this.startSessionTimer();
        this.setupBeforeUnload();
    }

    initializeElements() {
        this.statusDot = document.getElementById('statusDot');
        this.statusText = document.getElementById('statusText');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.interruptBtn = document.getElementById('interruptBtn');
        this.endBtn = document.getElementById('endBtn');
        this.conversationArea = document.getElementById('conversationArea');
        this.audioLevelFill = document.getElementById('audioLevelFill');
        this.sessionTimeEl = document.getElementById('sessionTime');
        this.messageCountEl = document.getElementById('messageCount');
        this.characterStatusEl = document.getElementById('characterStatus');
        this.loadingOverlay = document.getElementById('loadingOverlay');

        // Event listeners
        this.startBtn.addEventListener('click', () => this.startRecording());
        this.stopBtn.addEventListener('click', () => this.stopRecording());
        this.interruptBtn.addEventListener('click', () => this.interrupt());
        this.endBtn.addEventListener('click', () => this.showEndModal());
    }

    setupBeforeUnload() {
        this.beforeUnloadHandler = (event) => {
            if (!this.roleplayEnded) {
                event.preventDefault();
                event.returnValue = 'Are you sure you want to leave the roleplay session?';
                return 'Are you sure you want to leave the roleplay session?';
            }
        };
        window.addEventListener('beforeunload', this.beforeUnloadHandler);
    }

    removeBeforeUnload() {
        if (this.beforeUnloadHandler) {
            window.removeEventListener('beforeunload', this.beforeUnloadHandler);
            this.beforeUnloadHandler = null;
        }
    }

    showLoadingOverlay() {
        this.loadingOverlay.classList.add('show');
    }

    hideLoadingOverlay() {
        this.loadingOverlay.classList.remove('show');
    }

    connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/roleplay/{{ session.id }}/`;
        
        this.socket = new WebSocket(wsUrl);

        this.socket.onopen = () => {
            this.isConnected = true;
            this.updateConnectionStatus('Connected - {{ bot.name }} is ready', 'connected');
            this.enableControls();
            this.updateCharacterStatus('Ready');
            this.addMessage('system', 'Connected to {{ bot.name }}. Click "Start Recording" to begin.');
        };

        this.socket.onclose = () => {
            this.isConnected = false;
            this.updateConnectionStatus('Disconnected', 'disconnected');
            this.disableControls();
            this.updateCharacterStatus('Disconnected');
            this.addMessage('system', 'Connection lost');
        };

        this.socket.onerror = (error) => {
            this.updateConnectionStatus('Connection Error', 'disconnected');
            this.addMessage('system', 'Connection error occurred');
        };

        this.socket.onmessage = (event) => {
            this.handleMessage(JSON.parse(event.data));
        };
    }

    handleMessage(data) {
        switch (data.type) {
            case 'roleplay_start':
                this.addMessage('system', `{{ bot.name }} has joined the roleplay`);
                this.updateCharacterStatus('Active');
                break;

            case 'audio':
                this.handleAudioMessage(data);
                break;

            case 'audio_end':
                this.isBotSpeaking = false;
                this.updateCharacterStatus('Listening');
                break;

            case 'roleplay_transcript_update':
                this.handleTranscriptUpdate(data);
                break;

            case 'roleplay_complete':
                this.handleRoleplayComplete(data);
                break;

            case 'roleplay_info':
                this.updateSessionInfo(data);
                break;

            case 'error':
                this.addMessage('system', `Error: ${data.message}`);
                break;

            case 'insufficient_credits':
                this.handleInsufficientCredits(data);
                break;

            default:
                if (data.message) {
                    this.addMessage('system', data.message);
                }
        }
    }

    handleInsufficientCredits(data) {
        this.roleplayEnded = true;
        this.removeBeforeUnload();
        this.disableControls();
        this.updateConnectionStatus('Session Ended - No Credits', 'disconnected');
        this.updateCharacterStatus('Session Ended');
        this.addMessage('system', data.message);
        
        setTimeout(() => {
            alert(`Session ended due to insufficient credits!\n\nCredits used: ${data.credits_used}\n\nPlease purchase more credits to continue.`);
            window.location.href = '/voice_roleplay/';
        }, 2000);
    }

    handleAudioMessage(data) {
        if (!this.isBotSpeaking) {
            this.isBotSpeaking = true;
            this.updateCharacterStatus('Speaking');
        }
        this.enqueueAudio(data.audio);
    }

    handleTranscriptUpdate(data) {
        if (data.latest_items && data.latest_items.length > 0) {
            data.latest_items.forEach(item => {
                const role = item.role === 'assistant' ? 'assistant' : 'user';
                const speaker = item.role === 'assistant' ? '{{ bot.name }}' : 'You';
                this.addMessage(role, item.content, speaker);
            });
            this.messageCount = data.transcript_length;
            this.messageCountEl.textContent = this.messageCount;
        }
    }

    handleRoleplayComplete(data) {
        this.roleplayEnded = true;
        this.removeBeforeUnload();
        this.disableControls();
        this.updateConnectionStatus('Session Complete', 'connected');
        this.updateCharacterStatus('Complete');
        this.addMessage('system', `Roleplay with ${data.bot_name} completed successfully!`);
        
        setTimeout(() => {
            const creditsMsg = data.credits_used ? `\nCredits used: ${data.credits_used}` : '';
            alert(`Roleplay session completed!\n\nDuration: ${Math.floor(data.duration_seconds / 60)}:${(data.duration_seconds % 60).toString().padStart(2, '0')}\nMessages: ${data.transcript_length}${creditsMsg}`);
            window.location.href = '/voice_roleplay/';
        }, 1000);
    }

    async startRecording() {
        if (!this.isConnected) {
            this.addMessage('system', 'Not connected to character');
            return;
        }

        try {
            this.audioStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: this.SAMPLE_RATE,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                }
            });

            this.audioContext = new AudioContext({ sampleRate: this.SAMPLE_RATE });
            const source = this.audioContext.createMediaStreamSource(this.audioStream);
            
            // Volume monitoring
            this.analyser = this.audioContext.createAnalyser();
            source.connect(this.analyser);

            // Audio processing
            const bufferSize = 4096;
            const processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
            source.connect(processor);
            processor.connect(this.audioContext.destination);

            processor.onaudioprocess = (event) => {
                if (!this.isRecording || !this.isConnected) return;

                const inputData = event.inputBuffer.getChannelData(0);
                const pcm16Data = new Int16Array(inputData.length);
                
                for (let i = 0; i < inputData.length; i++) {
                    pcm16Data[i] = Math.round(Math.max(-1, Math.min(1, inputData[i])) * 32767);
                }

                const base64 = this.arrayBufferToBase64(pcm16Data.buffer);
                this.socket.send(JSON.stringify({
                    type: 'audio_data',
                    audio: base64,
                    format: 'pcm16',
                    sample_rate: this.SAMPLE_RATE,
                    channels: 1
                }));
            };

            this.processor = processor;
            this.isRecording = true;
            this.monitorVolume();
            
            // Send start recording signal
            this.socket.send(JSON.stringify({ type: 'start_recording' }));
            
            // Update UI
            this.startBtn.disabled = true;
            this.startBtn.textContent = 'Listening...';
            this.startBtn.classList.add('recording');
            this.stopBtn.disabled = false;
            this.updateCharacterStatus('Listening');
            
            this.addMessage('system', 'Started recording...');

        } catch (error) {
            this.addMessage('system', `Microphone error: ${error.message}`);
        }
    }

    stopRecording() {
        if (this.processor && this.isRecording) {
            this.processor.disconnect();
            this.processor = null;
            this.isRecording = false;

            if (this.audioStream) {
                this.audioStream.getTracks().forEach(track => track.stop());
            }

            if (this.audioContext) {
                this.audioContext.close();
            }

            if (this.isConnected) {
                this.socket.send(JSON.stringify({ type: 'stop_recording' }));
            }

            // Update UI
            this.startBtn.disabled = false;
            this.startBtn.textContent = 'Start Recording';
            this.startBtn.classList.remove('recording');
            this.stopBtn.disabled = true;
            this.updateCharacterStatus('Processing');
            
            this.addMessage('system', 'Stopped recording');
        }
    }

    interrupt() {
        if (this.isConnected) {
            this.socket.send(JSON.stringify({ type: 'interrupt' }));
            this.audioQueue = [];
            this.isBotSpeaking = false;
            this.updateCharacterStatus('Interrupted');
            this.addMessage('system', 'Interrupted {{ bot.name }}');
        }
    }

    showEndModal() {
        $('#endSessionModal').modal('show');
    }

    endRoleplay() {
        this.roleplayEnded = true;
        this.removeBeforeUnload();
        this.updateConnectionStatus('Ending session...', 'connecting');
        this.disableControls();
        this.showLoadingOverlay();
        
        if (this.isConnected) {
            this.socket.send(JSON.stringify({ type: 'end_roleplay' }));
        }
        
        this.addMessage('system', 'Roleplay session ended by user');
        $('#endSessionModal').modal('hide');
    }

    updateCharacterStatus(status) {
        this.characterStatusEl.textContent = status;
        this.characterStatusEl.className = 'character-status';
        
        if (status === 'Speaking') {
            this.characterStatusEl.classList.add('speaking');
        } else if (status === 'Processing') {
            this.characterStatusEl.classList.add('processing');
        }
    }

    updateConnectionStatus(message, type) {
        this.statusText.textContent = message;
        this.statusDot.className = `status-dot ${type}`;
    }

    addMessage(type, content, speaker = null) {
        const message = document.createElement('div');
        message.className = `conversation-message message-${type}`;
        
        const timestamp = new Date().toLocaleTimeString();
        
        if (type === 'system') {
            message.innerHTML = `<div class="message-content">${content}</div>`;
        } else {
            const displaySpeaker = speaker || (type === 'assistant' ? '{{ bot.name }}' : 'You');
            message.innerHTML = `
                <div class="message-header">
                    <span class="message-speaker">${displaySpeaker}</span>
                    <span class="message-time">${timestamp}</span>
                </div>
                <div class="message-content">${content}</div>
            `;
        }
        
        this.conversationArea.appendChild(message);
        this.conversationArea.scrollTop = this.conversationArea.scrollHeight;

        // Keep only last 50 messages
        const messages = this.conversationArea.children;
        if (messages.length > 50) {
            this.conversationArea.removeChild(messages[1]);
        }
    }

    monitorVolume() {
        if (!this.analyser || !this.isRecording) return;

        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const checkVolume = () => {
            if (!this.isRecording) return;

            this.analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            
            const rms = Math.sqrt(sum / bufferLength);
            const volume = (rms / 255) * 100;
            this.audioLevelFill.style.width = volume + '%';
            
            requestAnimationFrame(checkVolume);
        };
        
        checkVolume();
    }

    async enqueueAudio(base64Audio) {
        const pcm16 = new Int16Array(this.base64ToArrayBuffer(base64Audio));
        const float32 = new Float32Array(pcm16.length);
        
        for (let i = 0; i < pcm16.length; i++) {
            float32[i] = pcm16[i] / 32768.0;
        }
        
        this.audioQueue.push(float32);
        
        if (!this.isPlaying) {
            this.playNextChunk();
        }
    }

    async playNextChunk() {
        if (this.audioQueue.length === 0) {
            this.isPlaying = false;
            return;
        }

        this.isPlaying = true;
        const chunk = this.audioQueue.shift();

        if (!this.playbackContext || this.playbackContext.state === 'closed') {
            this.playbackContext = new AudioContext({ sampleRate: this.SAMPLE_RATE });
        }

        if (this.playbackContext.state === 'suspended') {
            await this.playbackContext.resume();
        }

        const buffer = this.playbackContext.createBuffer(1, chunk.length, this.playbackContext.sampleRate);
        buffer.copyToChannel(chunk, 0, 0);
        
        const source = this.playbackContext.createBufferSource();
        source.buffer = buffer;
        source.connect(this.playbackContext.destination);
        source.onended = () => this.playNextChunk();
        source.start();
    }

    startSessionTimer() {
        setInterval(() => {
            const elapsed = Math.floor((new Date() - this.sessionStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            this.sessionTimeEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
    }

    enableControls() {
        this.startBtn.disabled = false;
        this.interruptBtn.disabled = false;
        this.endBtn.disabled = false;
    }

    disableControls() {
        this.startBtn.disabled = true;
        this.stopBtn.disabled = true;
        this.interruptBtn.disabled = true;
        this.endBtn.disabled = true;
    }

    // Utility methods
    arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
}

// Global function for modal
function endRoleplay() {
    window.roleplaySession.endRoleplay();
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    window.roleplaySession = new RoleplaySession();
});
</script>
{% endblock %}