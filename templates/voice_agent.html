<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Agent</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.connecting { background-color: #fff3cd; color: #856404; }
        .status.connected { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .controls { text-align: center; margin: 20px 0; }
        button {
            background-color: #007bff; color: white; border: none; padding: 15px 30px;
            font-size: 16px; border-radius: 5px; cursor: pointer; margin: 0 10px; transition: background-color 0.3s;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        .recording { background-color: #dc3545 !important; }
        .logs { background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; padding: 15px; height: 300px; overflow-y: auto; font-family: monospace; font-size: 14px; margin-top: 20px; }
        .log-entry { margin: 5px 0; padding: 5px; border-radius: 3px; }
        .log-info { background-color: #d1ecf1; color: #0c5460; }
        .log-error { background-color: #f8d7da; color: #721c24; }
        .log-audio { background-color: #d4edda; color: #155724; }
        .volume-indicator { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; margin: 10px 0; overflow: hidden; }
        .volume-bar { height: 100%; background-color: #28a745; width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>
<div class="container">
    <h1>Voice Agent</h1>
    <div id="status" class="status connecting">Connecting...</div>
    <div class="controls">
        <button id="startBtn" disabled>Start Recording</button>
        <button id="stopBtn" disabled>Stop Recording</button>
        <button id="interruptBtn" disabled>Interrupt</button>
        <button id="testAudioBtn">Test Audio Playback</button>
    </div>
    <div>
        <label>Microphone Volume:</label>
        <div class="volume-indicator"><div id="volumeBar" class="volume-bar"></div></div>
    </div>
    <div class="logs" id="logs"></div>
</div>

<script>
class VoiceAgentClient {
    constructor() {
        this.socket = null;
        this.mediaRecorder = null;
        this.audioStream = null;
        this.audioContext = null;
        this.playbackContext = null;
        this.analyser = null;
        this.isRecording = false;
        this.isConnected = false;
        this.SAMPLE_RATE = 24000;

        // Queue for streaming audio
        this.audioQueue = [];
        this.isPlaying = false;

        this.initializeElements();
        this.connect();
    }

    initializeElements() {
        this.statusEl = document.getElementById('status');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.interruptBtn = document.getElementById('interruptBtn');
        this.testAudioBtn = document.getElementById('testAudioBtn');
        this.logsEl = document.getElementById('logs');
        this.volumeBar = document.getElementById('volumeBar');

        this.startBtn.addEventListener('click', () => this.startRecording());
        this.stopBtn.addEventListener('click', () => this.stopRecording());
        this.interruptBtn.addEventListener('click', () => this.interrupt());
        this.testAudioBtn.addEventListener('click', () => this.testAudioPlayback());
    }

    connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/voice-agent/`;

        this.socket = new WebSocket(wsUrl);

        this.socket.onopen = () => {
            this.isConnected = true;
            this.updateStatus('Connected to voice agent', 'connected');
            this.startBtn.disabled = false;
            this.interruptBtn.disabled = false;
        };

        this.socket.onclose = () => {
            this.isConnected = false;
            this.updateStatus('Disconnected from voice agent', 'error');
            this.startBtn.disabled = true;
            this.stopBtn.disabled = true;
            this.interruptBtn.disabled = true;
        };

        this.socket.onerror = (error) => {
            this.updateStatus('Connection error', 'error');
            this.logMessage('Connection error: ' + error, 'error');
        };

        this.socket.onmessage = (event) => {
            this.handleMessage(JSON.parse(event.data));
        };
    }

    handleMessage(data) {
        switch (data.type) {
            case 'session_ready': this.logMessage('âœ… ' + data.message, 'info'); break;
            case 'session_error': this.logMessage('âŒ Session Error: ' + data.message, 'error'); break;
            case 'agent_start': this.logMessage(`Agent started: ${data.agent_name}`, 'info'); break;
            case 'agent_end': this.logMessage(`Agent ended: ${data.agent_name}`, 'info'); break;
            case 'tool_start': this.logMessage(`Tool started: ${data.tool_name}`, 'info'); break;
            case 'tool_end': this.logMessage(`Tool ended: ${data.tool_name} - Output: ${data.output}`, 'info'); break;
            case 'audio':
                this.logMessage(`ðŸ”Š Received audio: ${(data.duration || 'unknown')}s`, 'audio');
                this.enqueueAudio(data.audio);
                break;
            case 'audio_end': this.logMessage('Audio playback ended', 'audio'); break;
            case 'audio_interrupted': this.logMessage('Audio interrupted', 'audio'); this.audioQueue = []; break;
            case 'error': this.logMessage('Error: ' + data.message, 'error'); break;
            case 'recording_started': this.logMessage(data.message, 'info'); break;
            case 'recording_stopped': this.logMessage('Recording stopped', 'info'); break;
            default: this.logMessage(`Unknown message type: ${data.type}`, 'info');
        }
    }

    async startRecording() {
        if (!this.isConnected) { this.logMessage('Not connected to voice agent', 'error'); return; }
        try {
            this.audioStream = await navigator.mediaDevices.getUserMedia({
                audio: { sampleRate: this.SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
            });
            this.audioContext = new AudioContext({ sampleRate: this.SAMPLE_RATE });
            const source = this.audioContext.createMediaStreamSource(this.audioStream);
            this.analyser = this.audioContext.createAnalyser();
            source.connect(this.analyser);

            // ScriptProcessorNode for capturing PCM16
            const bufferSize = 4096;
            const processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
            source.connect(processor);
            processor.connect(this.audioContext.destination);

            processor.onaudioprocess = (event) => {
                if (!this.isRecording || !this.isConnected) return;
                const inputData = event.inputBuffer.getChannelData(0);
                const pcm16Data = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) pcm16Data[i] = Math.round(Math.max(-1, Math.min(1, inputData[i])) * 32767);
                const base64 = this.arrayBufferToBase64(pcm16Data.buffer);
                this.socket.send(JSON.stringify({ type: 'audio_data', audio: base64, format: 'pcm16', sample_rate: this.SAMPLE_RATE, channels: 1 }));
            };

            this.processor = processor;
            this.isRecording = true;
            this.monitorVolume();
            this.socket.send(JSON.stringify({ type: 'start_recording' }));
            this.startBtn.disabled = true; this.startBtn.textContent = 'Recording...'; this.startBtn.classList.add('recording');
            this.stopBtn.disabled = false;
            this.logMessage('Recording started with PCM16 format', 'info');
        } catch (error) {
            this.logMessage('Error starting recording: ' + error.message, 'error');
        }
    }

    stopRecording() {
        if (this.processor && this.isRecording) {
            this.processor.disconnect(); this.processor = null; this.isRecording = false;
            if (this.audioStream) this.audioStream.getTracks().forEach(track => track.stop());
            if (this.audioContext) this.audioContext.close();
            if (this.isConnected) this.socket.send(JSON.stringify({ type: 'stop_recording' }));
            this.startBtn.disabled = false; this.startBtn.textContent = 'Start Recording'; this.startBtn.classList.remove('recording');
            this.stopBtn.disabled = true;
            this.logMessage('Recording stopped', 'info');
        }
    }

    interrupt() { if (this.isConnected) { this.socket.send(JSON.stringify({ type: 'interrupt' })); this.audioQueue = []; this.logMessage('Sent interrupt signal', 'info'); } }

    monitorVolume() {
        if (!this.analyser || !this.isRecording) return;
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const checkVolume = () => {
            if (!this.isRecording) return;
            this.analyser.getByteFrequencyData(dataArray);
            let sum = 0; for (let i = 0; i < bufferLength; i++) sum += dataArray[i]*dataArray[i];
            const rms = Math.sqrt(sum / bufferLength); const volume = (rms/255)*100;
            this.volumeBar.style.width = volume + '%';
            requestAnimationFrame(checkVolume);
        };
        checkVolume();
    }

    async enqueueAudio(base64Audio) {
        const pcm16 = new Int16Array(this.base64ToArrayBuffer(base64Audio));
        const float32 = new Float32Array(pcm16.length);
        for (let i = 0; i < pcm16.length; i++) float32[i] = pcm16[i]/32768.0;
        this.audioQueue.push(float32);
        if (!this.isPlaying) this.playNextChunk();
    }

    async playNextChunk() {
        if (this.audioQueue.length === 0) { this.isPlaying = false; return; }
        this.isPlaying = true;
        const chunk = this.audioQueue.shift();
        if (!this.playbackContext || this.playbackContext.state === 'closed') this.playbackContext = new AudioContext({ sampleRate: this.SAMPLE_RATE });
        if (this.playbackContext.state === 'suspended') await this.playbackContext.resume();

        const buffer = this.playbackContext.createBuffer(1, chunk.length, this.playbackContext.sampleRate);
        buffer.copyToChannel(chunk, 0, 0);
        const source = this.playbackContext.createBufferSource();
        source.buffer = buffer;
        source.connect(this.playbackContext.destination);
        source.onended = () => this.playNextChunk();
        source.start();
    }

    testAudioPlayback() {
        const duration = 1.0, frequency = 440;
        const samples = Math.floor(this.SAMPLE_RATE*duration);
        const testPCM16 = new Int16Array(samples);
        for (let i=0;i<samples;i++) testPCM16[i] = Math.round(Math.sin(2*Math.PI*frequency*i/this.SAMPLE_RATE)*0.3*32767);
        this.logMessage('ðŸ§ª Playing test tone (440Hz, 1s)', 'info');
        this.enqueueAudio(testPCM16.buffer);
    }

    arrayBufferToBase64(buffer) {
        let binary = ''; const bytes = new Uint8Array(buffer);
        for (let i=0;i<bytes.byteLength;i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i=0;i<binaryString.length;i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes.buffer;
    }

    updateStatus(message,type){this.statusEl.textContent=message;this.statusEl.className=`status ${type}`;}
    logMessage(message,type='info'){const entry=document.createElement('div');entry.className=`log-entry log-${type}`;entry.textContent=`${new Date().toLocaleTimeString()}: ${message}`;this.logsEl.appendChild(entry);this.logsEl.scrollTop=this.logsEl.scrollHeight;const entries=this.logsEl.children;if(entries.length>100)this.logsEl.removeChild(entries[0]);}
}

document.addEventListener('DOMContentLoaded',()=>{new VoiceAgentClient();});
</script>
</body>
</html>
